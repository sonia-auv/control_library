function [mv, onlinedata, info] = QPnlmpcmoveCodeGeneration(coredata, x, lastMV, onlinedata) 
%NLMPCMOVECODEGENERATION computes optimal control action from nonlinear
%MPC, represented by either "nlmpc" or "nlmpcMultistage" controllers.
%
%   [mv, onlinedata, info] = NLMPCMOVECODEGENERATION(coredata, x, lastmv, onlinedata)
%
%   Inputs:
%       coredata: structure that stores constant nonlinear MPC information
%              x: current states of the prediction model, specified as a column vector
%         lastMV: control signal used in the plant at the previous interval, specified as a column vector
%     onlinedata: structure that specifies runtime signals, plant parameters and initial guess
%
%   Both "coredata" and "onlinedata" structures should be generated by the
%   "getCodeGenerationData" command in advance and populated at run time
%   before calling "nlmpcmoveCodeGeneration".
% 
%   Outputs:
%             mv: optimal control action, returned a column vector.
%     onlinedata: structure updated with new initial guess of the decision
%                 variables for the next control interval.  
%           info: a structure with additional optimization information:
%                   MVopt: optimal MV sequence from time k to time k+p, returned as a (p+1)-by-nmv matrix.  
%                          Since MV at time k+p is not optimized by NLMPC, MVopt(p+1) is set to be equal to MVopt(p).
%                    Xopt: optimal state sequence from time k to time k+p, returned as a (p+1)-by-nx matrix.  
%                          Xopt(1,:) is the same as current state x.
%                    Topt: [0:p]*Ts, representing the time sequence used in prediction from time k to time k+p.
%                   Slack: slack variable at the optimum
%                ExitFlag: Exit code (positive: successful, 0: maximum number of iterations exceeded, negative: failed)
%              Iterations: number of iterations used by the solver
%                    Cost: Optimal cost, meaningful only when ExitFlag is positive.
%
%   When using "nlmpc", "info" also contains "Yopt", which is the optimal
%   output sequence from time k to time k+p, returned as a (p+1)-by-ny
%   matrix.  Yopt(1,:) is computed based on current state x.
%
%   A feasible suboptimal solution is returned only when ExitFlag is 0 and
%   "nlobj.Optimization.UseSuboptimalSolution" is true.
%
%   Example:
%       % obtain constant "coredata" and run-time "onlinedata" structures
%       [coredata, onlinedata] = getCodeGenerationData(nlobj, x, lastMV, parameters);
%       % populate appropriate fields in "onlinedata"
%       ...
%       [mv, onlinedata, info] = nlmpcmoveCodeGeneration(coredata, x, lastMV, onlinedata) ;
%
%   See also GETCODEGENERATIONDATA, NLMPCMOVE.

%   Author: N. L. Ricker, R. Chen
%   Copyright 1986-2020 The MathWorks, Inc.

%#codegen
narginchk(4,4);
%% process "coredata" structure
validateattributes(coredata,{'struct'},{'scalar','nonempty'},'nlmpcmoveCodeGeneration','"coredata"');
%% process "x" to get "nx-by-1" current states
validateattributes(x,{'double'},{'vector','nonempty','real','finite','nrows',coredata.nx},'nlmpcmoveCodeGeneration','"x"');
%% process "lastMV" to get "nmv-by-1" previous control action
validateattributes(lastMV,{'double'},{'vector','nonempty','real','finite','nrows',coredata.nmv},'nlmpcmoveCodeGeneration','"lastMV"');
%% process "onlinedata" structure
validateattributes(onlinedata,{'struct'},{'scalar','nonempty'},'nlmpcmoveCodeGeneration','"onlinedata"');
%% branch for @nlmpc and @nlmpcMultistage
if strcmp(coredata.Style,'General')
    %% process "ref" to get p-by-ny OV references
    ref0 = getPermanentValue(onlinedata,'ref');     
    %% process "MVTarget" to get p-by-nmv MV references
    MVTarget0 = getPermanentValue(onlinedata,'MVTarget');
    %% process "md" to get (p+1)-by-nmd MD signal
    if coredata.nmd>0
        md0 = getPermanentValue(onlinedata,'md');
    else
        md0 = []; % dummy
    end
    %% process parameters to get a cell vector with npara elements
    if coredata.npara>0
        Parameters0 = getPermanentValue(onlinedata,'Parameters');
    else
        Parameters0 = {}; % dummy
    end
    %% process X0 to get p-by-nx
    X0 = getPermanentValue(onlinedata,'X0');
    %% process MV0 to get p-by-nmv
    MV0 = getPermanentValue(onlinedata,'MV0');
    %% process Slack0 (default to 0)
    Slack0 = getPermanentValue(onlinedata,'Slack0');
    %% process weights to get p-by-(ny/nmv) weights (default to coredata)
    OutputWeights0 = getOptionalValue(onlinedata,'OutputWeights');
    MVWeights0 = getOptionalValue(onlinedata,'MVWeights');
    MVRateWeights0 = getOptionalValue(onlinedata,'MVRateWeights');
    ECRWeight0 = getOptionalValue(onlinedata,'ECRWeight');
    %% process constraints to get p-by-(ny/nx/nmv) constraints (scaled, default to coredata)
    % we don't check conflict between Min and Max at runtime
    OutputMin0 = getOptionalValue(onlinedata,'OutputMin');
    OutputMax0 = getOptionalValue(onlinedata,'OutputMax');
    StateMin0 = getOptionalValue(onlinedata,'StateMin');
    StateMax0 = getOptionalValue(onlinedata,'StateMax');
    MVMin0 = getOptionalValue(onlinedata,'MVMin');
    MVMax0 = getOptionalValue(onlinedata,'MVMax');
    MVRateMin0 = getOptionalValue(onlinedata,'MVRateMin');
    MVRateMax0 = getOptionalValue(onlinedata,'MVRateMax');
    %% generate runtime data and user data 
    [runtimedata, userdata, z0] = znlmpc_generateRuntimeData(...
        coredata, x, lastMV, ref0, MVTarget0, md0, ...
        OutputWeights0, MVWeights0, MVRateWeights0, ECRWeight0, ...
        OutputMin0, OutputMax0, StateMin0, StateMax0, ...
        MVMin0, MVMax0, MVRateMin0, MVRateMax0, ...
        Parameters0, X0, MV0, Slack0);
    %% generate function handles from function names
    handles = struct(...
        'hStateFcn', getFunctionHandle(coredata.strStateFcn,'Model.StateFcn'), ... 
        'hOutputFcn', getFunctionHandle(coredata.strOutputFcn,'Model.OutputFcn'), ... 
        'hCostFcn', getFunctionHandle(coredata.strCostFcn,'Optimization.CustomCostFcn'), ... 
        'hEqConFcn', getFunctionHandle(coredata.strEqConFcn,'Optimization.CustomEqConFcn'), ... 
        'hIneqConFcn', getFunctionHandle(coredata.strIneqConFcn,'Optimization.CustomIneqConFcn'), ... 
        'hJacobianStateFcn', getFunctionHandle(coredata.strJacobianStateFcn,'Jacobian.StateFcn'), ... 
        'hJacobianOutputFcn', getFunctionHandle(coredata.strJacobianOutputFcn,'Jacobian.OutputFcn'), ... 
        'hJacobianCostFcn', getFunctionHandle(coredata.strJacobianCostFcn,'Jacobian.CustomCostFcn'), ... 
        'hJacobianEqConFcn', getFunctionHandle(coredata.strJacobianEqConFcn,'Jacobian.CustomEqConFcn'), ... 
        'hJacobianIneqConFcn', getFunctionHandle(coredata.strJacobianIneqConFcn,'Jacobian.CustomIneqConFcn'));
    %% generate decision variable bounds (for states and the slack variable because they are always hard constraints)
   % [zLB, zUB] = znlmpc_getZBounds(coredata, runtimedata, userdata, handles.hCostFcn, z0);
    %% generate linear inequality constraints (for MVs and MV rates)
    %[A, B] = znlmpc_getUBounds(coredata, runtimedata);
    %% generate wrapper nonlinear cost and constraint function handles with Jacobian
    % note that OV bounds are part of the nonlinear constraints
    % must force "z" to be column vector to help "codegen" determine sizes
   % CostFcn = @(z) znlmpc_objfun(z(:), coredata, runtimedata, userdata, handles);
  %  ConFcn = @(z) znlmpc_confun(z(:), coredata, runtimedata, userdata, handles);
    %% generate "fmincon" solver options (cannot pass in)
    [H, f, A, b, Aeq, beq, LB, UB] = nlmpc_getQPMatrices(coredata, runtimedata, userdata, handles, z0);
    
    opt = optimoptions('quadprog', ...
                	'Display', 'none', ...
                    'ConstraintTolerance', coredata.solveroptionsConstraintTolerance, ...
                    'OptimalityTolerance', coredata.solveroptionsOptimalityTolerance, ...
                    'StepTolerance', coredata.solveroptionsStepTolerance, ...
                    'MaxIterations', coredata.solveroptionsMaxIterations);
    %% call fmincon
    [z, cost, ExitFlag, Out] = quadprog(H, f, A, b, Aeq, beq, LB, UB, z0, opt);
    %% if exitflag is 0 but z is infeasible, change exitflag to -2
    if (ExitFlag == 0) && (Out.constrviolation > opt.ConstraintTolerance)
        ExitFlag = -2;
    end                
    %% create optimal trajectories
    % must force "z" to be column vector to help "codegen" determine sizes
    [X, U, e] = znlmpc_getXUe(coredata, z(:), x, runtimedata.md);
    %% return mv depending on solver exit flag and suboptimal choice.  
    if ExitFlag > 0 || (coredata.usesuboptimalsolution && ExitFlag == 0)
        mv = U(1,coredata.imv)';
    else
        mv = lastMV;
    end
    %% return optimal moves, initial guess and other information
    if nargout <= 2
        [newX0, newMV0, newSlack0] = znlmpc_computeInfo(coredata, X, U, e, cost, ExitFlag, Out.iterations, handles.hOutputFcn, runtimedata.Parameters);
    else
        [newX0, newMV0, newSlack0, info] = znlmpc_computeInfo(coredata, X, U, e, cost, ExitFlag, Out.iterations, handles.hOutputFcn, runtimedata.Parameters);
    end
    onlinedata.X0 = newX0;
    onlinedata.MV0 = newMV0;
    onlinedata.Slack0 = newSlack0;
else
    %% onlinedata.InitialGuess must by nZ-by-1
    validateattributes(onlinedata.InitialGuess,{'double'},{'vector','nonempty','real','finite','nrows',coredata.nZ},'nlmpcmoveCodeGeneration','"onlinedata.InitialGuess"');
    %% if onlinedata has online bounds, make it full matrix
    StateMin0 = localExtendBounds(onlinedata,'StateMin',coredata.p);
    StateMax0 = localExtendBounds(onlinedata,'StateMax',coredata.p);
    MVMin0 = localExtendBounds(onlinedata,'MVMin',coredata.p);
    MVMax0 = localExtendBounds(onlinedata,'MVMax',coredata.p);
    MVRateMin0 = localExtendBounds(onlinedata,'MVRateMin',coredata.p);
    MVRateMax0 = localExtendBounds(onlinedata,'MVRateMax',coredata.p);
    %% get function handles
    handles = struct(...
        'StateFcn', getFunctionHandle(coredata.strStateFcn,'Model.StateFcn'), ...
        'dStateFcn', getFunctionHandle(coredata.strdStateFcn,'Model.StateJacFcn'), ...
        'CostFcn', getStageFuncionHandleCellArray(coredata.strCostFcn,'Stage.CostFcn'),...
        'EqConFcn', getStageFuncionHandleCellArray(coredata.strEqConFcn,'Stage.EqConFcn'),...
        'IneqConFcn', getStageFuncionHandleCellArray(coredata.strIneqConFcn,'Stage.IneqConFcn'),...
        'dCostFcn', getStageFuncionHandleCellArray(coredata.strdCostFcn,'Stage.CostJacFcn'),...
        'dEqConFcn', getStageFuncionHandleCellArray(coredata.strdEqConFcn,'Stage.EqConJacFcn'),...
        'dIneqConFcn', getStageFuncionHandleCellArray(coredata.strdIneqConFcn,'Stage.IneqConJacFcn'));
    %% generate inputs for fmincon
    if coredata.hasmvrate
        % initial guess
        z0 = zmsnlmpc_getInitialGuessXMVDMVE(coredata,onlinedata,x,lastMV);
        % decision variable bounds
        [zLB, zUB] = zmsnlmpc_getZBoundsXMVDMVE(coredata, StateMin0, StateMax0, MVMin0, MVMax0, MVRateMin0, MVRateMax0);
        % linear inequality constraints (for initializing with x[k] and mv[k-1] and dmv equations)
        [Aeq, Beq] = zmsnlmpc_getLinearEqConXMVDMVE(coredata, onlinedata, x, lastMV);
        % cost and constraint wrapper functions with Jacobian
        CostFcn = @(z) zmsnlmpc_objfunXMVDMVE(z(:), coredata, handles, onlinedata);
        ConFcn = @(z) zmsnlmpc_confunXMVDMVE(z(:), coredata, handles, onlinedata);
    else
        % initial guess
        z0 = zmsnlmpc_getInitialGuessXMVE(coredata,onlinedata,x,lastMV);
        % decision variable bounds
        [zLB, zUB] = zmsnlmpc_getZBoundsXMVE(coredata, StateMin0, StateMax0, MVMin0, MVMax0);
        % linear inequality constraints (for initializing with x[k])
        [Aeq, Beq] = zmsnlmpc_getLinearEqConXMVE(coredata, onlinedata, x);
        % cost and constraint wrapper functions with Jacobian
        CostFcn = @(z) zmsnlmpc_objfunXMVE(z(:), coredata, handles, onlinedata);
        ConFcn = @(z) zmsnlmpc_confunXMVE(z(:), coredata, handles, onlinedata);
    end
    %% generate "fmincon" solver options (cannot pass in)
    opt = optimoptions(...
        'fmincon', ...
        'Algorithm','sqp', ...
        'Display','off', ...
        'SpecifyConstraintGradient', true, ...
        'SpecifyObjectiveGradient', true, ...
        'ConstraintTolerance',coredata.solveroptionsConstraintTolerance,...
        'MaxIterations',coredata.solveroptionsMaxIterations,...
        'ObjectiveLimit',coredata.solveroptionsObjectiveLimit,...
        'OptimalityTolerance',coredata.solveroptionsOptimalityTolerance,...
        'ScaleProblem',coredata.solveroptionsScaleProblem,...
        'StepTolerance',coredata.solveroptionsStepTolerance);
    %% call fmincon
    [z, cost, ExitFlag, Out] = fmincon(CostFcn, z0, [], [], Aeq, Beq, zLB, zUB, ConFcn, opt);
    %% if exitflag is 0 but z is infeasible, change exitflag to -2
    if (ExitFlag == 0) && (Out.constrviolation > opt.ConstraintTolerance)
        ExitFlag = -2;
    end                
    %% return mv depending on solver exit flag and suboptimal choice.  
    if ExitFlag > 0 || (ExitFlag == 0 && coredata.usesuboptimalsolution && ~coredata.hascustomsolver)
        % return the optimal solution or feasible suboptimal solution
        mv = z(coredata.mvStart(1):coredata.mvEnd(1));
    else
        % otherwise, freeze
        mv = lastMV;
    end        
    %% return optimal moves, initial guess and other information
    [info, onlinedata.InitialGuess] = zmsnlmpc_computeInfo(coredata, z, ExitFlag, Out.iterations, cost);
end

%% Utility functions
function val = getPermanentValue(structure, field)
% no error checking
if isfield(structure, field)
    val = structure.(field);
else
    coder.internal.errorIf(true,'MPC:object:errAnonymousFcnHandleCodeGen',field);
end

function val = getOptionalValue(structure, field)
% no error checking
if isfield(structure, field)
    val = structure.(field);
else
    val = [];
end

function fcn = getFunctionHandle(str, type)
tmp = strtrim(str);
if isempty(tmp)
    fcn = [];
else
    coder.internal.errorIf(~coder.target('MATLAB')&&contains(tmp,'@'),'MPC:utility:errAnonymousFcnHandleCodeGen',type);
    fcn = str2func(tmp);
end

function array = getStageFuncionHandleCellArray(fcn, type)
len = size(fcn,1);
array = cell(len,1);
for ct=1:len
    array{ct} = getFunctionHandle(fcn(ct,:), type);
end
array = {array};

function new = localExtendBounds(data,field,p)
% old is not empty and [1..p]-by-n, new is p-by-n
if isfield(data,field)
    if isempty(data.(field))
        new = [];
    else
        old = data.(field);
        len = size(old,1);
        if len>p
            new = old(1:p,:);
        elseif len<p
            new = [old;repmat(old(end,:),p-len,1)];
        else 
            new = old;
        end
    end
else
    new = [];
end